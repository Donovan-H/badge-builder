<link rel="import" href="../../bower_components/polymer/polymer.html">
<!-- <link rel="import" href="../../bower_components/paper-radio-button/paper-radio-button.html">
<link rel="import" href="../../bower_components/paper-radio-group/paper-radio-group.html"> -->
<link rel="import" href="../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">

<!-- TODO: make html import -->
<script src="../../bower_components/lodash/lodash.min.js"></script>

<!--
A question element with a yes/no response

Example:

    <multiple-choice question="Which shapes have more than 7 sides?" answer='["Nonagon","Decagon"]' options='["Pentagon","Heptagon","Nonagon","Decagon"]'></multiple-choice>

@demo
-->
<dom-module id="multiple-choice">

  <style>
    :host {
      display: block;
      box-sizing: border-box;
    }

    paper-input {
      display: inline-block;
    }

    .question {
      width: 100%;
    }

    .group {
      display: inline-block;
    }

    .inline>* {
      display: inline-block;
    }
  </style>

  <template>
    <p class="question" hidden=[[edit]]>[[question]]</p>
    <div>
      <paper-input class="question" placeholder="Question" value="{{question}}" hidden=[[!edit]]></paper-input>
    </div>

    <template id="choices" is="dom-repeat" items="[[_options.list]]" on-dom-change="_templateUpdated">
      <div class="group">
        <paper-checkbox id="[[item.key]]" name="[[item.value]]" class="options">
          <span hidden=[[edit]]>[[item.value]]</span>
        </paper-checkbox>
        <paper-input placeholder="Option" value="{{item.value}}" hidden=[[!edit]]></paper-input>
      </div>
    </template>

    <div class="inline">
      <paper-fab mini icon="add" hidden=[[!edit]] on-tap="addOption"></paper-fab>
      <paper-fab mini icon="remove" hidden=[[!edit]] on-tap="removeOption"></paper-fab>
    </div>
  </template>

</dom-module>

<script>

  MultipleChoice = Polymer({

    is: 'multiple-choice',

    properties: {

      /**
       * The id of the element
       * @type {string}
       */
      _id: {
        type: String,
        value: function() {
          return "";
        }
      },

      /**
       * The element type. This should be the same as the web component name
       * @type {string}
       */
      elementType: {
        type: String,
        value: function() {
          return "multiple-choice";
        }
      },

      /**
       * The question.
       *
       * @type {string}
       */
      question: {
        type: String,
        // value: function() {
        //   return 'Which are the odd numbers?';
        // }
      },

      /**
       * We needed an object for binding instead as the dynamic options array duplicates items with same value
       *
       * @type {object}
       */
      _options: {
        type: Object,
        value: function() {
          return {};
          //return { list: [] };
        }
      },

      /**
       * The possible answer to choose from.
       *
       * @type {array}
       */
      options: {
        type: Array,
        observer: '_optionsChanged',
        // value: function() {
        //   return [
        //     "One",
        //     "Two",
        //     "Three",
        //     "Four"
        //   ];
        // }
      },

      /**
       * The answer.
       *
       * @type {array}
       */
      answer: {
        type: Array,
        // value: function() {
        //   return [
        //     "One",
        //     "Three"
        //   ];
        // }
      },

      /**
       * Result of user's answer.
       *
       * @type {boolean}
       */
      result: {
        type: Boolean,
        observer: '_resultChanged'
      },

      /**
       * `edit` indicates that the element should be in WYSIWYG editor mode.
       */
      edit: {
        type: Boolean,
        value: false,
        observer: '_editChanged'
      },

      /**
       * `data` contains the edited properties
       */
      // data: {
      //   type: Object,
      //   readOnly: true,
      //   computed: '_dataUpdated(_id, elementType, question, answer, options, _options)'
      // }

    },

    // Element Lifecycle

    ready: function() {
      // `ready` is called after all elements have been configured, but
      // propagates bottom-up. This element's children are ready, but parents
      // are not.
      //
      // This is the point where you should make modifications to the DOM (when
      // necessary), or kick off any processes the element wants to perform.
    },

    attached: function() {
      // `attached` fires once the element and its parents have been inserted
      // into a document.
      //
      // This is a good place to perform any work related to your element's
      // visual state or active behavior (measuring sizes, beginning animations,
      // loading resources, etc).
    },

    detached: function() {
      // The analog to `attached`, `detached` fires when the element has been
      // removed from a document.
      //
      // Use this to clean up anything you did in `attached`.
    },

    // Element Behavior

    _templateUpdated: function(ev) {
      // console.log(this.localName, 'template changed', ev );
      this._editChanged(); // fire when dom elements are stamped to DOM
    },

    /**
     * Handler when number of options is changed
     */
    _optionsChanged: function() {
      console.log("-- populating options --");
      this._updateBindingOptions(this.options);
    },



    /**
     * Copies options for dynamic binding
     */
    _updateBindingOptions: function(options){
      var list = [];
      var i = this.options.length;
      while(i--){
        var option = this.options[i];
        var optionObject = {
          id: i,
          value: option,
        }
        list.unshift(optionObject);
      }
      this.set('_options.list', list);
      console.log(this.localName, '* options', this.options, this._options.list);
    },

    /**
     * The `multiple-choice-result` event is fired whenever an answer is selected or changed.
     *
     * @event multiple-choice-answer
     * @detail {boolean}
     */
    _resultChanged: function(newValue) {
      //console.info(this.localName, 'fire result:', this.result);
      this.fire('multiple-choice-result', {result: this.result}); // dispatches event with result
    },

    /**
     * Triggered when you select an answer
     */
    _selectAnswer: function(ev) {
      if (this.edit) {
        this._editAnswer();
        return;
      }
      var result = this.checkAnswer();
      console.log(this.localName, 'result:', result);
      this.set('result', result); // update result
    },

    /**
     * Returns the selected answer.
     *
     * NB: We can't rely on 'paper-radio-group' methods to get selected items
     * as we want to use various nested elements which results in empty 'items' array.
     */
    getSelectedAnswer: function() {
      var answer = [];
      var items = this.querySelectorAll('.options'); // paper-radio-button or paper-checkbox
      var i = items.length;
      while(i--){
        var item = items[i];
        //console.log("item", item.checked, item.name);
        if (item.checked && item.name) {
          answer.push(item.name);
        }
      }
      return _.sortBy(answer);
    },

    _selectItemValues: function(values) {
      //var template = this.querySelector('#choices');
      var dynamicNodeExists = this.$$('.group');
      if (!dynamicNodeExists){
        return; // error did not find dynamic node
      }
      //var items = this.querySelectorAll('paper-radio-button');
      var items = Polymer.dom(this.root).querySelectorAll('.options'); // paper-radio-button or paper-checkbox
      var i = items.length;
      //console.log("Found options:", i, items);
      while(i--){
        var item = items[i];
        var value = item.name;
        var index = _.findIndex(values, function(v){
          return (v === value);
        });
        //console.log('â€¢', value, index, values );
        if ( index > -1 ) {
          item.checked = true;
        } else {
          item.checked = false;
        }
      }
    },

    /**
     * Checks if your answer is correct.
     */
    checkAnswer: function() {
      var selectedAnswer = _.sortBy(this.getSelectedAnswer());
      var answer = _.sortBy(this.answer); // _.map(this.answer, 'value')
      //console.log(selectedAnswer, "===", answer);
      return _.isEqual(selectedAnswer, answer);
    },

    /**
     * Toggle edit mode
     */
    toggleEdit: function() {
      this.set('edit', !this.edit);
    },

    /**
     * Triggered when edit mode is changed
     */
    _editChanged: function(newValue) {
      if (!this.edit) {
        return;
      }
      // edit mode - set/reset selection to correct answer
      //var answer = this.answer; //_.map(this.answer, 'value');
      //console.log(this.localName, 'answer:', answer, 'options:', this.options);
      this._selectItemValues(this.answer);
    },

    /**
     * Edit the correct answer
     */
    _editAnswer: function(){
      var selectedAnswer = this.getSelectedAnswer();
      this.set('answer', selectedAnswer); // update answer property
      console.info(this.localName, "edited answer", this.answer);
    },

    addOption: function() {
      console.log('add new option');
      //this.push('options', '');
      var obj = {
        key: this._options.list.length+1,
        value: ""
      }
      this.push('_options.list', obj);
      console.log("> push", obj.key, obj.value);
    },

    removeOption: function() {
      console.log('remove last option');
      //this.pop('options');
      this.pop('_options.list');
    },

    // _listOptionsChanged: function() {
    //   console.log("Deep observer > ", this.data);
    //   //this._dataUpdated(this._id, this.elementType, this.question, this.answer, this.options, this._options);
    // },

    // data updated method is invoked to calculate the value whenever any of the argument values changes.
    // _dataUpdated: function(id, elementType, question, answer, options, _options) {
    //   // use edit options // _.map(this._options.list, 'value');
    //   var sortedAnswers = _.sortBy(answer);
    //   var editOptions = options;
    //   if(_options.list){
    //     editOptions = _.chain(_options.list)
    //                     .clone() // just the properties
    //                     .map('value') // just the value property
    //                     .compact() // remove blank and duplicate strings
    //                     .value();
    //     console.log('*', editOptions);
    //   }
    //   console.log('@', editOptions, _options);
    //   var data = {
    //     "_id" : id,
    //     "elementType" : elementType,
    //     "question" : question,
    //     "answer" : sortedAnswers,
    //     "options" : editOptions
    //   };
    //   console.info(this.localName, '=', data.options);
    //   return data;
    // },

    getData: function() {
      var sortedAnswers = _.sortBy(this.answer);
      var editOptions = this.options;
      if(this._options.list){
        editOptions = _.chain(this._options.list)
                        .clone() // just the properties
                        .map('value') // just the value property
                        .compact() // remove blank and duplicate strings
                        .value();
        console.log('**', editOptions);
      }
      console.log('@@', editOptions, this._options);

      return {
        _id: this._id,
        elementType: this.elementType,
        question: this.question,
        answer: sortedAnswers,
        options: editOptions
      }
    },

    listeners: {
      "change": "_selectAnswer"
    },

    // NB: Using deep observer to watch object property
    // observers: [
    //   '_listOptionsChanged(_options.list.*)'
    // ]

  });

</script>
